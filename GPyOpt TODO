TODO list

- check why some samples jump out of the range
- implement Mike's loss function
- check why exact gradients dont work
- pack the paralellization
- test (or remove) sparse GPy's
- write manuals

-- implement DIRECT and CMA optimization

-------------------------------------------------------------
IDEA of the implementation from robo


import DIRECT as _DIRECT
def _DIRECT_acquisition_fkt_wrapper(acq_f):
def _l(x, user_data):
return -acq_f(np.array([x])), 0
return _l
def DIRECT(acquisition_fkt, X_lower, X_upper):
x, fmin, ierror = _DIRECT.solve(_DIRECT_acquisition_fkt_wrapper(acquisition_fkt), l=[X_lower], u=[X_upper], maxT=2000, maxf=2000)
return np.array([x])
except Exception, e:
def DIRECT(acquisition_fkt, X_lower, X_upper):
raise NotImplementedError("cannot find DIRECT library")


try:
import cma as _cma
def _cma_fkt_wrapper(acq_f, derivative=False):
def _l(x, *args, **kwargs):
x = np.array([x])
return -acq_f(x, derivative=derivative, *args, **kwargs)[0]
return _l
def cma(acquisition_fkt, X_lower, X_upper):
# stdout = sys.stdout
# sys.stdout = StringIO.StringIO()
x = _cma.fmin(_cma_fkt_wrapper(acquisition_fkt), (X_upper + X_lower) * 0.5, 0.6, options={"bounds":[X_lower, X_upper], "verbose":-1, "verb_log":sys.maxint})[0]
# sys.stdout = stdout
return np.array(x)
except Exception, e:
def cma(acquisition_fkt, X_lower, X_upper):
raise NotImplementedError("cannot find cma library")

